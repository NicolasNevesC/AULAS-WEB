# Relacionamentos com Entity Framework

[ðŸ“½ Veja esta vÃ­deo-aula no Youtube](https://youtu.be/kC-BWUBh6A4)

Vamos avanÃ§ar no estudo de Entity Framework (EF) trabalhando agora com mÃºltiplas tabelas relacionadas.

Para os exemplos dessa aula, usaremos o modelo `hamburgueria`, disponÃ­vel [aqui](https://github.com/ermogenes/hamburgueria-mysql). Crie o seu banco localmente, seguindo as instruÃ§Ãµes de uso do repositÃ³rio.

![](https://github.com/ermogenes/hamburgueria-mysql/raw/main/assets/hamburgueria.png)

Para esses exemplos adicionamos as seguintes referÃªncias:

```cs
using System.Linq;
using Microsoft.EntityFrameworkCore;
```

Para todos os exemplo, o contexto deve estar disponÃ­vel. NÃ£o indicaremos em todos os exemplos por simplicidade.

```cs
using (var db = new hamburgueriaContext())
{
    // o exemplo vai aqui
}
```

## Obtendo mÃºltiplos registros

Fazendo referÃªncia direta aos objetos do contexto temos acesso aos dados das tabelas.

Exemplo. Obter todos os burguers:

```cs
var todosOsBurguers = db.Burguer.ToList();
```

O mÃ©todo `ToList` foi adicionado para que a consulta seja _materializada_, ou seja, executada imediatamente, pois o EF sÃ³ as executa quando necessÃ¡rio, aguardando o mÃ¡ximo possÃ­vel.

ApÃ³s a execuÃ§Ã£o, `todosOsBurguers` possui uma lista de objetos do tipo `Burguer`, cada um equivalente a uma linha da tabela. VocÃª pode iterar entre eles com `foreach` (podendo, assim, retirar o `ToList`, jÃ¡ que a consulta Ã© materializada automaticamente.).

```cs
var todosOsBurguers = db.Burguer;
foreach(var burguer in todosOsBurguers) 
{
    string nomeBurguer = burguer.Nome;
    decimal precoBurguer = burguer.Preco;
    Console.WriteLine($"O burguer {nomeBurguer} custa {precoBurguer:C}.");
}
```

SaÃ­da:

```
O burguer git push custa R$ 25,00.
O burguer Arrow function custa R$ 12,99.
O burguer String custa R$ 9,99.
O burguer Seletor CSS custa R$ 12,99.
```

## Filtrando a lista com `Where`

Podemos gerar filtros SQL _where_ usando o mÃ©todo `Where`. Ele recebe uma _arrow function_ passando a linha, e espera um _boolean_ indicando se a linha fica ou nÃ£o no resultado final.

Exemplo. Obter somente os burguers que custam entre 10 e 20 reais:

```cs
var burguersEntre10e20 = db.Burguer.Where(b => b.Preco >= 10 && b.Preco <= 20);
foreach(var burguer in burguersEntre10e20) 
{
    string nomeBurguer = burguer.Nome;
    decimal precoBurguer = burguer.Preco;
    Console.WriteLine($"O burguer {nomeBurguer} custa {precoBurguer:C}.");
}
```

Em `db.Burguer.Where(b => b.Preco >= 10 && b.Preco <= 20)`:
- `b` representa a linha atual a ser testada (pode ser dado qualquer nome);
- `b.Preco >= 10 && b.Preco <= 20` Ã© a condiÃ§Ã£o para a linha constar no resultado.

SaÃ­da:

```
O burguer Arrow function custa R$ 12,99.
O burguer Seletor CSS custa R$ 12,99.
```

## Ordenando uma lista

Usamos os mÃ©todos `OrderBy` e `OrderByDescending` para ordenar a lista por um campo especÃ­fico. A palavra `Descending` indica que a ordenaÃ§Ã£o Ã© invertida.

Para adicionar uma ordenaÃ§Ã£o por outro campo em caso de coincidÃªncia no primeiro, use `ThenBy` e `ThenByDescending`.

Veja algumas possÃ­veis construÃ§Ãµes:

```cs
// Ordenado por preÃ§o, do menor para o maior
db.Burguer.OrderBy(b => b.Preco)

// Ordenado por preÃ§o, do maior para o menor
db.Burguer.OrderByDescending(b => b.Preco)

// Ordenado por preÃ§o, do menor para o maior...
// ... e para os preÃ§os coincidentes, ordenado por nome, de Z a A
db.Burguer.OrderBy(b => b.Preco).ThenByDescending(b => b.Nome)
```

Exemplo. Ordenar os burguers por preÃ§o e depois por nome de Z a A:

```cs
var burguersOrdenados = db.Burguer
    .OrderBy(b => b.Preco)
    .ThenByDescending(b => b.Nome);
foreach(var burguer in burguersOrdenados) 
{
    Console.WriteLine($"O burguer {burguer.Nome} custa {burguer.Preco:C}.");
}
```

SaÃ­da: 

```
O burguer String custa R$ 9,99.
O burguer Seletor CSS custa R$ 12,99.
O burguer Arrow function custa R$ 12,99.
O burguer git push custa R$ 25,00.
```

Podemos filtrar e ordenar na mesma consulta.

Exemplo. Burguers que custam menos de 20 reais, os mais baratos primeiro:

```cs
var burguers = db.Burguer
    .Where(b => b.Preco < 20)
    .OrderBy(b => b.Preco);
foreach(var burguer in burguers) 
{
    Console.WriteLine($"O burguer {burguer.Nome} custa {burguer.Preco:C}.");
}
```

SaÃ­da: 

```
O burguer String custa R$ 9,99.
O burguer Arrow function custa R$ 12,99.
O burguer Seletor CSS custa R$ 12,99.
```

## Navegando entre tabelas

Ao realizar o _scaffolding_ do banco de dados o EF criou propriedades que permitem navegar nas suas tabelas relacionadas. Por exemplo, dado que eu tenho um ingrediente, esse ingrediente possui um tipo. A descriÃ§Ã£o desse tipo, porÃ©m, estÃ¡ na tabela de tipos de ingredientes.

![](000235.png)

![](000233.png)

![](000234.png)

Vamos tentar obter a descriÃ§Ã£o usando as propriedades de navegaÃ§Ã£o:

```cs
var ingredientes = db.Ingrediente;
foreach(var ingrediente in ingredientes) 
{
    string nome = ingrediente.Nome;
    string tipo = ingrediente.TipoIngrediente.Descricao;
    Console.WriteLine($"O ingrediente {nome} Ã© do tipo {tipo}.");
}
```

Obtemos o seguinte erro o executar:

```
Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
```

Quando fizemos `ingrediente.TipoIngrediente.Descricao` tentamos navegar da tabela ingrediente para a tabela de tipo de ingrediente, mas os dados nÃ£o vieram do banco de dados. Para que eles venham, eles precisam ser incluÃ­dos na consulta, exatamente como em um _join_ em SQL. Fazemos isso usando o mÃ©todo `Include`.

Exemplo. Todos os ingredientes e seus tipos.

```cs
var ingredientes = db.Ingrediente
    .Include(i => i.TipoIngrediente);
foreach(var ingrediente in ingredientes) 
{
    string nome = ingrediente.Nome;
    string tipo = ingrediente.TipoIngrediente.Descricao;
    Console.WriteLine($"O ingrediente {nome} Ã© do tipo {tipo}.");
}
```

SaÃ­da: 

```
O ingrediente PÃ£o Comum Ã© do tipo PÃ£o.
O ingrediente PÃ£o com Gergelim Ã© do tipo PÃ£o.
O ingrediente PÃ£o Integral Ã© do tipo PÃ£o.
O ingrediente PÃ£o Australiano Ã© do tipo PÃ£o.
O ingrediente Burguer de Fraldinha Ã© do tipo Carne.
O ingrediente Burguer de Picanha Ã© do tipo Carne.
O ingrediente Burguer Mix da Casa Ã© do tipo Carne.
O ingrediente Cheddar Ã© do tipo Extra.
O ingrediente JalapeÃ±o Ã© do tipo Extra.
O ingrediente Alface Ã© do tipo Extra.
O ingrediente Bacon Ã© do tipo Extra.
O ingrediente Queijo MuÃ§arela Ã© do tipo Extra.
O ingrediente Mostarda Ã© do tipo Extra.
```

Para filtrar, temos que executar o filtro na tabela adequada, usando as propriedades de navegaÃ§Ã£o.

```cs
var ingredientes = db.Ingrediente
    .Include(i => i.TipoIngrediente)
    .Where(i => i.Nome.Contains("fra") && i.TipoIngrediente.Descricao == "Carne");
```

Com esse filtro, somente terÃ­amos `O ingrediente Burguer de Fraldinha Ã© do tipo Carne.`.

## MÃºltiplos relacionamentos

Digamos que queiramos exibir os ingredientes dos burguers. Atente Ã  modelagem:

![](000236.png)

![](000238.png)

![](000239.png)

![](000237.png)

Esta informaÃ§Ã£o estÃ¡ na tabela que vincula ingredientes com burguers. Precisamos consultÃ¡-la e incluir as demais tabelas que possuem os dados que nos interessam.

```cs
var ingredientesDosBurguers = db.BurguerIngrediente
    .Include(bi => bi.Burguer)
    .Include(bi => bi.Ingrediente);
foreach(var ingredienteBurguer in ingredientesDosBurguers) 
{
    Burguer burguer = ingredienteBurguer.Burguer;
    Ingrediente ingrediente = ingredienteBurguer.Ingrediente;
    Console.WriteLine($"O burguer {burguer.Nome} leva {ingrediente.Nome}.");
}
```

SaÃ­da:

```
O burguer git push leva Cheddar.
O burguer git push leva JalapeÃ±o.
O burguer git push leva PÃ£o Australiano.
O burguer git push leva Bacon.
O burguer git push leva Burguer de Picanha.       
O burguer git push leva Mostarda.
O burguer Arrow function leva Cheddar.
O burguer Arrow function leva PÃ£o Integral.       
O burguer Arrow function leva Bacon.
O burguer Arrow function leva Burguer Mix da Casa.
O burguer String leva PÃ£o Comum.
O burguer String leva Burguer de Fraldinha.
O burguer String leva Queijo MuÃ§arela.
O burguer Seletor CSS leva Alface.
O burguer Seletor CSS leva PÃ£o com Gergelim.
O burguer Seletor CSS leva Burguer Mix da Casa.
O burguer Seletor CSS leva Mostarda.
```

Perceba:

- Todos os `Includes` partem da tabela inicial, `db.BurguerIngrediente`.
- Podemos pegar referÃªncias aos objetos como um todo, ao invÃ©s de referÃªncias diretas aos valores.

Todas as tabelas incluÃ­das podem ser usadas em filtros e ordenaÃ§Ã£o.

Exemplo. Filtro usando `Burguer.Nome` e ordenaÃ§Ã£o usando `Ingrediente.Nome`:

```cs
var ingredientesDosBurguers = db.BurguerIngrediente
    .Include(bi => bi.Burguer)
    .Include(bi => bi.Ingrediente)
    .Where(bi => bi.Burguer.Nome == "git push")
    .OrderBy(bi => bi.Ingrediente.Nome);
foreach(var ingredienteBurguer in ingredientesDosBurguers) 
{
    Burguer burguer = ingredienteBurguer.Burguer;
    Ingrediente ingrediente = ingredienteBurguer.Ingrediente;
    Console.WriteLine($"O burguer {burguer.Nome} leva {ingrediente.Nome}.");
}
```

SaÃ­da:

```
O burguer git push leva Bacon.
O burguer git push leva Burguer de Picanha.
O burguer git push leva Cheddar.
O burguer git push leva JalapeÃ±o.
O burguer git push leva Mostarda.
O burguer git push leva PÃ£o Australiano.
```

Caso precisemos de navegaÃ§Ãµes adicionais, podemos incluir quantas tabelas forem necessÃ¡rias. Digamos que queremos exibir a quantidade de cada ingrediente. O valor numÃ©rico estÃ¡ presente na tabela consultada, mas temos que incluir tambÃ©m as unidades.

```cs
var ingredientesDosBurguers = db.BurguerIngrediente
    .Include(bi => bi.Burguer)
    .Include(bi => bi.Ingrediente)
    .Include(bi => bi.Unidade)
    .Where(bi => bi.Burguer.Nome == "git push")
    .OrderBy(bi => bi.Ingrediente.Nome);
foreach(var ingredienteBurguer in ingredientesDosBurguers) 
{
    Burguer burguer = ingredienteBurguer.Burguer;
    Ingrediente ingrediente = ingredienteBurguer.Ingrediente;
    int quantidade = ingredienteBurguer.Quantidade;
    string unidade = ingredienteBurguer.Unidade.Descricao;
    string descricaoIngrediente = $"{quantidade} {unidade} de {ingrediente.Nome}";
    Console.WriteLine($"O burguer {burguer.Nome} leva {descricaoIngrediente}.");
}
```

SaÃ­da:

```
O burguer git push leva 1 porÃ§Ã£o(Ãµes) de Bacon.
O burguer git push leva 200 grama(s) de Burguer de Picanha.
O burguer git push leva 1 porÃ§Ã£o(Ãµes) de Cheddar.
O burguer git push leva 1 porÃ§Ã£o(Ãµes) de JalapeÃ±o.
O burguer git push leva 1 porÃ§Ã£o(Ãµes) de Mostarda.
O burguer git push leva 1 unidade(s) de PÃ£o Australiano.
```

Digamos que precisamos dos dados do tipo de cada ingrediente, por exemplo para exibir ou ordenar por tipo, ou para filtrar exibindo somente os pÃ£es, por exemplo. NÃ£o podemos incluir os tipos de ingredientes diretamente, pois nÃ£o hÃ¡ navegaÃ§Ã£o direta, somente via ingredientes.

![](000240.png)

Para fazer essas inclusÃµes indiretas, usamos `ThenInclude` na tabela intermediÃ¡ria.

Exemplo. Exibir os pÃ£es de cada burguer:

```cs
var ingredientesDosBurguers = db.BurguerIngrediente
    .Include(bi => bi.Burguer)
    .Include(bi => bi.Ingrediente)
        .ThenInclude(i => i.TipoIngrediente)
    .Where(bi => bi.Ingrediente.TipoIngrediente.Descricao == "PÃ£o");
foreach(var ingredienteBurguer in ingredientesDosBurguers) 
{
    Burguer burguer = ingredienteBurguer.Burguer;
    Ingrediente ingrediente = ingredienteBurguer.Ingrediente;
    Console.WriteLine($"O burguer {burguer.Nome} leva {ingrediente.Nome}.");
}
```

SaÃ­da:

```
O burguer String leva PÃ£o Comum.
O burguer Seletor CSS leva PÃ£o com Gergelim.
O burguer Arrow function leva PÃ£o Integral.
O burguer git push leva PÃ£o Australiano.
```

## Limitando o nÃºmero de resultados

Para realizar paginaÃ§Ã£o podemos restringir a quantidade de registros retornados usando `Take` e pular uma quantidade especÃ­fica usando `Skip`.

Exemplo. Todos os ingredientes:

```cs
foreach(var ingrediente in db.Ingrediente) 
{
    Console.WriteLine(ingrediente.Nome);
}
```

SaÃ­da:

```
Cheddar
PÃ£o Comum
Burguer de Fraldinha
JalapeÃ±o
Alface
PÃ£o com Gergelim
PÃ£o Integral
PÃ£o Australiano
Bacon
Burguer de Picanha
Queijo MuÃ§arela
Burguer Mix da Casa
Mostarda
```

Exemplo. Os 3 primeiros ingredientes:

```cs
foreach(var ingrediente in db.Ingrediente.Take(3)) 
{
    Console.WriteLine(ingrediente.Nome);
}
```

SaÃ­da:

```
Cheddar
PÃ£o Comum
Burguer de Fraldinha
```

Exemplo. Os 3 prÃ³ximos ingredientes:

```cs
foreach(var ingrediente in db.Ingrediente.Skip(3).Take(3)) 
{
    Console.WriteLine(ingrediente.Nome);
}
```

SaÃ­da:

```
JalapeÃ±o
Alface
PÃ£o com Gergelim
```

## Obtendo registros Ãºnicos

Enquanto `ToList` nos retorna uma lista com todos os resultados da consulta, mas podemos trazer um registro somente. Isso Ã© especialmente Ãºtil para filtrar uma tabela pela sua chave primÃ¡ria.

MÃ©todo | Somente um resultado | Mais de um | Nenhum
--- | --- | --- | ---
`Single` | Retorna o objeto encontrado | LanÃ§a exceÃ§Ã£o | LanÃ§a exceÃ§Ã£o
`SingleOrDefault` | Retorna o objeto encontrado | LanÃ§a exceÃ§Ã£o | Retorna `null`

Podemos usÃ¡-los independentemente, ou de forma semelhante a `Where`, jÃ¡ com o filtro incorporado.

```cs
Burguer barato = db.Burguer.Where(b => b.Preco < 10).SingleOrDefault();
Console.WriteLine(barato != null ? "encontrado" : "nÃ£o encontrado"); // encontrado

Burguer caro = db.Burguer.SingleOrDefault(b => b.Preco > 200);
Console.WriteLine(caro != null ? "encontrado" : "nÃ£o encontrado"); // nÃ£o encontrado
```

TambÃ©m podemos usar `First` ou `Last` para recuperar o primeiro e o Ãºltimo registro de uma lista.

MÃ©todo | Somente um resultado | Mais de um | Nenhum
--- | --- | --- | ---
`First` | Retorna o objeto | Retorna o primeiro objeto | LanÃ§a exceÃ§Ã£o
`FirstOrDefault` | Retorna o objeto | Retorna o primeiro objeto | Retorna `null`
`Last` | Retorna o objeto | Retorna o Ãºltimo objeto | LanÃ§a exceÃ§Ã£o
`LastOrDefault` | Retorna o objeto | Retorna o Ãºltimo objeto | Retorna `null`

## FunÃ§Ãµes agregadas

As funÃ§Ãµes a seguir realizam processamentos nas linhas, e retornam valores Ãºnicos em vez dos registros.

- `Count` retorna o nÃºmero de registros encontrados. Pode receber o filtro.
- `Max` retorna o maior valor encontrado na coluna indicada.
- `Min` retorna o menor valor encontrado na coluna indicada.
- `Sum` retorna a soma dos valores encontrados na coluna indicada.
- `Average` retorna a mÃ©dia dos valores encontrados na coluna indicada.

```cs
int qtdBurguers = db.Burguer.Count();
int qtdBurguersAbaixoDe10Reais = db.Burguer.Count(b => b.Preco < 10);
int qtdBurguersAcimaDe10Reais = db.Burguer.Where(b => b.Preco > 10).Count();
decimal menorPreco = db.Burguer.Min(b => b.Preco);
decimal maiorPreco = db.Burguer.Max(b => b.Preco);
decimal precoMedio = db.Burguer.Average(b => b.Preco);
decimal precoUmDeCada = db.Burguer.Sum(b => b.Preco);

Console.WriteLine($"Quantos hamburguers? {qtdBurguers}");
Console.WriteLine($"Abaixo de R$ 10,00: {qtdBurguersAbaixoDe10Reais}");
Console.WriteLine($"Acima de R$ 10,00: {qtdBurguersAcimaDe10Reais}");
Console.WriteLine($"Menor preÃ§o: {menorPreco:C}");
Console.WriteLine($"Maior preÃ§o: {maiorPreco:C}");
Console.WriteLine($"PreÃ§o mÃ©dio: {precoMedio:C}");
Console.WriteLine($"Quanto custa comprar um de cada: {precoUmDeCada:C}");
```

SaÃ­da:

```
Quantos hamburguers? 4
Abaixo de R$ 10,00: 1
Acima de R$ 10,00: 3
Menor preÃ§o: R$ 9,99
Maior preÃ§o: R$ 25,00
PreÃ§o mÃ©dio: R$ 15,24
Quanto custa comprar um de cada: R$ 60,97
```

HÃ¡ tambÃ©m mÃ©todos que retornam um _boolean_ e podem ser usado para avaliar condiÃ§Ãµes.

- `All` retorna `true` se todos os registros passarem na condiÃ§Ã£o.
- `Any` retorna `true` se o resultado possuir um ou mais registros.

```cs
bool algumBurguerCaro = db.Burguer.Where(b => b.Preco > 20).Any();
bool algumBurguerBarato = db.Burguer.Any(b => b.Preco < 10);
bool todosBuguersAcima15e50 = db.Burguer.All(b => b.Preco > 15.5m);

Burguer meuBurguer = db.Burguer.Single(b => b.Nome == "Arrow function");
bool meuBurguerPossuiCarne = db.BurguerIngrediente
        .Include(bi => bi.Ingrediente)
            .ThenInclude(i => i.TipoIngrediente)
        .Where(bi => bi.Burguer == meuBurguer)
        .Any(bi => bi.Ingrediente.TipoIngrediente.Descricao == "Carne");

Console.WriteLine($"algumBurguerCaro: {algumBurguerCaro}");
Console.WriteLine($"algumBurguerBarato: {algumBurguerBarato}");
Console.WriteLine($"meuBurguerPossuiCarne: {meuBurguerPossuiCarne}");
Console.WriteLine($"todosBuguersAcima15e50: {todosBuguersAcima15e50}");
```

SaÃ­da:

```
algumBurguerCaro: True
algumBurguerBarato: True
meuBurguerPossuiCarne: True
todosBuguersAcima15e50: False
```
